%% Header
%
%   This function fits Gaussian functions to the intensity profiles
%   generated by fitPeaks for peak calling and quantification.
%
%   Inputs: data_struct: data structure containing the data set with the
%                        following fields:
%                              - int_prof: matrix containing the intensity
%                                          profiles
%
%           num_peaks (optional): number of expected peaks
%                                 can be 1, 2, or 3. Default is 1
%                                 
%           snr_threshold(optional): Threshold value of signal-to-noise 
%                                    ratio (SNR).Lanes with at least 1 peak
%                                    with an estimated SNR greater than the
%                                    threshold value will be curve fit. 
%                                    Typical threshold value is 3.
%
%
%   Outputs: 
% Struct [structure]: A data structure containing objects (Intensity 
%                     profiles for each ROI, 3D matrix with each ROI 
%                     contained in a different z, and coordinates of 
%                     the ROIs).
%   struct.rois: 3D matrix with each ROI contained in a different z.
%   struct.angle: The angle of rotation to straighten the image (number, in degrees).
%   struct.rotate: The angle of rotation required to display the image with
%   separations running vertically instead of horizontally (number, in
%   degrees).
%   struct.array_bounds: User selected boundaries of the array as a 3x2
%   matrix (rows contain upper left, upper right, and lower left
%   coordinates respectively; first column contains x-coordinates; second column contains y-coordinates). 
%   struct.name: The name of the protein target entered by the user
%   (string).
%   struct.wells_per_row: The number of wells per row based on the user
%   selected array bounds and horizontal well spacing.
%   struct.rows: Number of rows in the array
%   struct.int_prof: a 3D matrix containing an array of the intensity 
%                    profiles [x, intensity value] indexed by the 
%                    third dimension
%   struct.good_indices: vector of indices of the intensity profiles and
%                        ROIs that were fit with Gaussian peaks (i.e. 
%                        passed the SNR threshold)
%   struct.good_devices: boolean vector indicating the good devices 
%   struc.fit_coefficients: m x 3 x p matrix containing the gaussian fit
%                           coefficients. m is the number of peaks and p                
%                           is the number of good devices (good_devices)                
%   struct.R2: m x 1 matrix containing the R^2 valuesof the Gaussian fits.
%              m is the numberof good devices (good_devices)
%   struct.ci: 2m x 3 x p matrix containing the gaussian fit confidence
%              intervals for each parameter. m is the number of peaks and p
%              is the number of good devices
%
%   Versions: - 0.1 (4.7.16) Function created
%             - 0.2 Now should be called before goodProfiles()
%             - 0.3 (5.15.16) Data between the user selected  peak boundaries 
%                   is now used for the gaussian fit (instead of the entire
%                   intensity profile).
%             - 0.4 (8.18.17) Function updated with iterative Gaussian fitting 
%                   for noisy data (first fit refines data to be fit within
%                   the peak bounds of the first fit). Also added a field
%                   to the struct that contains the confidence intervals
%                   for the Gaussian fit parameters.
%             
%               
%
function data_struct = fitPeaks_beads(data_struct, num_peaks, snr_threshold)
%% Check input arguments
switch nargin
    
    % If only the data_structure is provided, set num_peaks = 1
    case 1
        
        num_peaks = 1;
        
    % If provided, ensure the number of peaks is valid
    case 2
        % Exit function if an invalid number of peaks is input
        if ((num_peaks > 3) || (num_peaks < 1))
            
            error('Invalid number of peaks');
            
            return
            
        end
        %If only 2 input arguments provided, user does not want to run the
        %SNR threshold
        apply_snr_threshold=0;
    case 3
        apply_snr_threshold=1;
        %
    otherwise
        
        error('Invalid number of input arguments');
            
        return
    
    
end


%% Get the peaks

% Get the intensity profiles
try 
    intensity_profiles = data_struct.int_prof;

catch 
    
    error('Error accessing data_struct.int_prof');
    
end

% Find all of the good wells
[x_dim,y_dim,z_dim]=size(intensity_profiles);

%store to the structure the starting number of wells analyzed
struct.total_wells=z_dim;


if apply_snr_threshold==1    
    % for loop to filter out SNR<3 lanes with a conservative SNR estimate 
    %calculated from the max intensity of a smooth data set and the standard 
    %deviation of the last 5 pixels of the lane.
    snr3_devices=zeros(z_dim,1);
    snr_est=zeros(z_dim,1);

    %figure
        for i=1:z_dim
            device=intensity_profiles(:,:,i);
            xval=device(:,1);
            yval=device(:,2);
            yvalsmooth=smooth(yval);
	
            noise_est=std(yval(end-5:end));
	
            signal_est=max(yvalsmooth);
	
            snr_est(i)=signal_est/noise_est;
    
                if snr_est(i)<snr_threshold
                    snr3_devices(i)=0;
                else
                    snr3_devices(i)=1;
                    %plot(xval,yval);
                    %hold on
                end
        end
    struct.snr_est=snr_est;
    
    % Get the number of good wells
    num_good_devices = sum(snr3_devices);
    good_indices=find(snr3_devices==1);
    % Exit if there are no good wells
    if (num_good_devices == 0)
    
        error('No good wells in data_struct');
    
    end
else
    num_good_devices=ones(z_dim,1);
    good_indices=find(num_good_devices==1);
end

% Save the good indices
data_struct.good_indices = good_indices;

%% Get the seed parameters



% Let the user select the points for the parameter estimation

bounds_set = false;

while (~bounds_set)
    
    % Plot the good devices
    figure(1);
    hold on

    for i = 1:num_good_devices

        device_index = good_indices(i);

        plot(intensity_profiles(:,1, device_index),...
            intensity_profiles(:,2, device_index), '-k');

    end

    hold off
    
    uiwait(msgbox('Please select left and right boundaries of each peak'));
    
    % Get the limits of the plot
    y_lim = get(gca, 'YLim');
    
    % Preallocate the nx2 matrix to hold the peak bounds, where n is the
    % number of peaks. Col 1 is the left bound, col 2 is the right bound
    peak_bounds = zeros(num_peaks, 2);
    
    for peak = 1:num_peaks
       
        % Get the left peak boundary
        [x1, y1] = ginput(1);
        
        % Draw the selected peak boundary
        line([x1, x1], y_lim, 'Color', [0, 0, 1]);
        
        
        % Get the right peak boundary
        [x2, y2] = ginput(1);
        
        % Draw the selected peak boundary
        line([x2, x2], y_lim, 'Color', [0, 1, 0]);
        
        % Save the selected bounds
        
        peak_bounds(peak, :) = [x1, x2];
        
          
    end
    
    % Ask if the peaks are correct
    choice = questdlg('Are the peak bounds correct?', ...
	'Done with bound selection?', ...
	'Yes', 'No','No');

    close
   
    % If they are done, exit loop
    if (strcmp(choice, 'Yes'))
       
        bounds_set = true;
        
    end
    
    

end
close all;

% Save the bounds
data_struct.fit_bounds = peak_bounds;

%% Create the fit options

% Create the fit options object with the specified number of peaks

fit_type = 'gauss1';
         
fit_options = fitoptions(fit_type);  

% Assign the locations to the fit options object
for peak = 1:num_peaks
    
    % Get the left and right bound for the peak
    left_bound = peak_bounds(peak, 1);
    right_bound = peak_bounds(peak, 2);
    
    % Set the sigma bounds
    sigma_min = 0;
    sigma_max = right_bound - left_bound;
    
    % Set the peak center bounds
    x_min = left_bound;
    x_max = right_bound;
    
    x_min_all(peak) = x_min;
    x_max_all(peak) = x_max;
    
    % Set the ampitude bounds
    a_min = 0;
    a_max = y_lim(2);
    
    % set the upper and lower bounds. correct for difference in c and
    % sigma terms
     lower_mat(((3*peak)-2):3*peak) = [a_min, x_min, (sigma_min * sqrt(2))];
     upper_mat(((3*peak)-2):3*peak) = [a_max, x_max, (sigma_max * sqrt(2))];

end


%% Fit each peak

% Preallocate the m x 3 x p matrix for the fit coefficients were m is the 
% number of peaks per roi and p is the number of ROIs and col 1 is the 
% amplitude, col 2 is the peak center, and col 3 is sigma
data_struct.fit_coefficients = zeros(num_peaks, 3, length(good_indices));
data_struct.ci = zeros(num_peaks*2, 3, length(good_indices));

% Preallocate the m x 1 matrix for the R^2 values for each fit where
% m is the number of good devices
data_struct.R2 = zeros(num_good_devices, 1);

for i = 1:num_good_devices
    
    device_index = good_indices(i);
    
    % Display the device number every 50 devices
    %if(mod(i, 50) == 0)
        
        %fprintf('Fitting lane %d/%d\n', i, num_good_devices);
        
    %end
    
    % Get the x and y values
    x = intensity_profiles(:,1, device_index);
    y = intensity_profiles(:,2, device_index);
    
    for peak = 1:num_peaks
       
       upper_lim = upper_mat(((3*peak)-2):3*peak); 
       lower_lim = lower_mat(((3*peak)-2):3*peak);
       
       x_min = lower_lim(2);
       x_max = upper_lim(2);
       
       fit_options.Lower = lower_lim;
       fit_options.Upper = upper_lim;
    
       % Determine index of x_min and x_max for selection of x and y values in
       %the region of the peak
       left_diff=abs(x-x_min);
       left_data=find(left_diff==min(left_diff));
    
       right_diff=abs(x-x_max);
       right_data=find(right_diff==min(right_diff));
    
       % Get the x and y values in the peak region
       x_fit=x(left_data:right_data);
        y_fit=y(left_data:right_data);
    
       % Fit the peaks
    
    [fit_object, gof2] = fit(x_fit, y_fit, fit_type, fit_options);
    
    % Get the coefficients
    fit_coeffs = coeffvalues(fit_object);
    ci = confint(fit_object, 0.95);
        
    % Get peak center and width for re-fitting of peak
        center=fit_coeffs(2);
        sigma=fit_coeffs(3);
        width=sigma/sqrt(2);
        
       % Determine index of x_min and x_max for selection of x and y values in
       %closer to the peak
       left_diff=abs(x_fit-(center-2*width));
       left_data=find(left_diff==min(left_diff));
    
       right_diff=abs(x_fit-(center+2*width));
       right_data=find(right_diff==min(right_diff));
    
       % Get the x and y values in the peak region
       x_fit2=x_fit(left_data:right_data);
        y_fit2=y_fit(left_data:right_data);
    
       if length(x_fit2) > 3
        % Fit the peaks again
         [fit_object2, gof2] = fit(x_fit2, y_fit2, fit_type, fit_options); 
       
        % Get the coefficients
        fit_coeffs = coeffvalues(fit_object2);
        ci = confint(fit_object2, 0.95);
       end
       % Get peak center and width for AUC calculation
        center=fit_coeffs(2);
        sigma=fit_coeffs(3);
        width=sigma/sqrt(2);
        
        %determine location of +/- 2 peak widths from the peak center
        auc_left_bound=center-2*width;
        auc_right_bound=center+2*width;
        
        % Determine index of auc_left_bound and auc_right_bound for selection of x and y values in
        %the region of the peak
        left_diff_auc=abs(x-auc_left_bound);
        left_data_auc=find(left_diff_auc==min(left_diff_auc));
    
        right_diff_auc=abs(x-auc_right_bound);
        right_data_auc=find(right_diff_auc==min(right_diff_auc));
        
        % Make sure the left bound is within the array
        if (left_data_auc < 1)
           
           left_data_auc = 1; 
            
        end
        
        
        % Check to make sure the AUC bounds are within the bounds of the
        % array
        if (right_data_auc > length(y))
            
            right_data_auc = length(y);
            
            
        end
    
        %Sum data within the peak bounds
        peak_region_intensities=y(left_data_auc:right_data_auc);
        AUC(peak,1,i)=sum(peak_region_intensities);
    
        data_struct.fit_coefficients(peak, :, i) =...
            fit_coeffs;
        data_struct.ci((peak*2-1):(peak*2), :, i) =...
            ci;
        data_struct.AUC(peak,1,i)=AUC(peak,1,i);
        
        %get the R^2 values
        all_r2(peak,1,i) = gof2.rsquare;
    end
    
    % Save the R^2 value to the struct
    data_struct.R2 = all_r2;
    
end

end
